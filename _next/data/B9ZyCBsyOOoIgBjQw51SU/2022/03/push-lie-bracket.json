{"pageProps":{"post":{"title":"Lie括弧積の押し出し","date":"2022-03-28","tags":"math","year":"2022","month":"03","slug":"push-lie-bracket","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h2: \"h2\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"成分表示に頼らずに書く。\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"接ベクトル\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\qq*{曲線}c&\\\\colon (a,b)\\\\to M\\\\quad(a<0<b)\\\\\\\\\n  \\\\qq*{多様体上の関数}f&\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"を用いて\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  X&\\\\in T_{c(0)}M\\\\\\\\\n  \\\\eval{\\\\dv{f(c(t))}{t}}_{t=0}&\\\\eqqcolon X[f]\\\\in \\\\R\n\\\\end{align}`\n        }), \"によって点\", _jsx(\"span\", {\n          children: `$\\\\hspace{0.2em}c(0)\\\\hspace{0.2em}$`\n        }), \"における接ベクトルを定義する。\", _jsx(\"span\", {\n          children: `$M\\\\hspace{0.2em}$`\n        }), \"上のベクトル場は\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\mathfrak{X}(M)\\\\ni X&\\\\colon M\\\\to TM\\\\qc p\\\\mapsto \\\\eval{X}_p\n\\\\end{align}`\n        }), \"と、多様体上の各点に接ベクトルを対応付ける関数と見なせる。\", _jsx(\"span\", {\n          children: `$f\\\\hspace{0.2em}$`\n        }), \"を作用させたものは\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  X&\\\\in \\\\mathfrak{X}(M)\\\\\\\\\n  f&\\\\colon M\\\\to\\\\R\\\\\\\\\n  X[f]&\\\\colon M\\\\to\\\\R\\\\qc p\\\\mapsto \\\\eval{\\\\dv{f(c(t))}{t}}_{c^{-1}(p)}\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"微分写像\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          children: `$\\\\hspace{0.2em}f\\\\colon M\\\\to N\\\\hspace{0.2em}$`\n        }), \"に対して微分写像\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f_\\\\ast&\\\\colon T_pM\\\\to T_{f(p)}N\n\\\\end{align}`\n        }), \"が誘導出来て\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  g&\\\\colon N\\\\to \\\\R\\\\\\\\\n  \\\\qq*{ベクトル}V&\\\\in T_pM\\\\\\\\\n  \\\\qq*{ベクトル}f_\\\\ast V&\\\\in T_{f(p)}N\\\\\\\\\n  (f_\\\\ast V)[g]&\\\\coloneqq V[g\\\\circ f]\\\\in\\\\R\n\\\\end{align}`\n        }), \"と定義される。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"ベクトル場の押し出しは\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f&\\\\colon M\\\\to N\\\\\\\\\n  g&\\\\colon N\\\\to \\\\R\\\\\\\\\n  X&\\\\in \\\\mathfrak{X}(M)\\\\\\\\\n  X[g\\\\circ f]&=f_\\\\ast X[g]\\\\circ f\\\\colon M\\\\to\\\\R\\\\\\\\\n  f_\\\\ast X[g]&\\\\colon N\\\\to \\\\R\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Lie括弧積\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\qq*{ベクトル場}X,Y,\\\\comm{X}{Y}&\\\\in\\\\mathfrak{X}(M)\\\\\\\\\n  f&\\\\colon M\\\\to\\\\R\\\\\\\\\n  \\\\comm{X}{Y}f&\\\\coloneqq X[Y[f]]-Y[X[f]]\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"\\r\\nLie括弧積が1階微分になることを成分に依らず示すことはできるのだろうか。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Lie括弧積の押し出し\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(\"span\", {\n          children: `$f_\\\\ast\\\\comm{X}{Y}=\\\\comm{f_\\\\ast X}{f_\\\\ast Y}\\\\hspace{0.2em}$`\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  g&\\\\colon N\\\\to\\\\R\\\\\\\\\n  (f_\\\\ast\\\\comm{X}{Y})[g]\\\\circ f&=\\\\comm{X}{Y}(g\\\\circ f)\\\\\\\\\n  &=X[Y[g\\\\circ f]]-Y[X[g\\\\circ f]]\\\\\\\\\n  &=X[f_\\\\ast Y[g]\\\\circ f]-Y[f_\\\\ast X[g]\\\\circ f]\\\\\\\\\n  &=f_\\\\ast X[f_\\\\ast Y[g]]\\\\circ f-f_\\\\ast Y[f_\\\\ast X[g]]\\\\circ f\\\\\\\\\n  &=(\\\\comm{f_\\\\ast X}{f_\\\\ast Y}g)\\\\circ f\n\\\\end{align}`\n        }), \"ただし等号は関数としてのものである。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"引き戻し\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"ベクトルについては\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  V&\\\\in T_pM\\\\qc \\\\omega\\\\in T^\\\\ast_{f(p)}N\\\\\\\\\n  f&\\\\colon M\\\\to N\\\\\\\\\n  \\\\ev{f^\\\\ast \\\\omega, V}&\\\\coloneqq \\\\ev{\\\\omega, f_\\\\ast V}\\\\in\\\\R\n\\\\end{align}`\n        }), \"であり、ベクトル場については\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  V&\\\\in \\\\mathfrak{X}(M)\\\\qc \\\\omega\\\\in \\\\Omega(N)\\\\\\\\\n  f&\\\\colon M\\\\to N\\\\\\\\\n  \\\\ev{f^\\\\ast \\\\omega, V}&=\\\\ev{\\\\omega, f_\\\\ast V}\\\\circ f\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          children: `$\\\\hspace{0.2em}r$`\n        }), \"-形式については\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f&\\\\colon M\\\\to N\\\\qc\\\\omega\\\\in\\\\Omega^r(M)\\\\\\\\\n  (f^\\\\ast\\\\omega)(X_1,\\\\dots,X_r)&\\\\coloneqq \\\\omega(f_\\\\ast X_1,\\\\dots,f_\\\\ast X_r)\\\\in\\\\R\\\\quad(X_i\\\\in T_pM)\\\\\\\\\n  (f^\\\\ast\\\\omega)(X_1,\\\\dots,X_r)&= \\\\omega(f_\\\\ast X_1,\\\\dots,f_\\\\ast X_r)\\\\circ f\\\\colon M\\\\to\\\\R\\\\quad(X_i\\\\in\\\\mathfrak{X}(M))\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"外微分\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\dd{\\\\omega}(X,Y)&=X[\\\\omega(Y)]-Y[\\\\omega(X)]-\\\\omega(\\\\comm{X}{Y})\n\\\\end{align}`\n        }), \"と展開できることを用いて\\r\\n\", _jsx(\"p\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\omega&\\\\in \\\\Omega^2(N)\\\\qc X,Y\\\\in \\\\mathfrak{X}(M)\\\\qc f\\\\colon M\\\\to N\\\\\\\\\n  \\\\dd(f^\\\\ast\\\\omega)(X,Y)&=X[f^\\\\ast\\\\omega(Y)]-Y[f^\\\\ast\\\\omega(X)]\\\\circ f-f^\\\\ast\\\\omega(\\\\comm{X}{Y})\\\\\\\\\n  &=X[\\\\omega(f_\\\\ast Y)\\\\circ f]-Y[\\\\omega(f_\\\\ast X)\\\\circ f]-\\\\omega(f_\\\\ast\\\\comm{X}{Y}\\\\circ f)\\\\\\\\\n  &=f_\\\\ast X[\\\\omega(f_\\\\ast Y)]\\\\circ f-f_\\\\ast Y[\\\\omega(f_\\\\ast X)]\\\\circ f-\\\\omega(\\\\comm{f_\\\\ast X}{f_\\\\ast Y}\\\\circ f)\\\\\\\\\n  &=\\\\dd{\\\\omega}(f_\\\\ast X,f_\\\\ast Y)\\\\circ f\\\\\\\\\n  &=f^\\\\ast(\\\\dd{\\\\omega})(X,Y)\n\\\\end{align}`\n        }), \"と、外微分と引き戻しが可換であることが分かる。\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"mathblocks":[]},"__N_SSG":true}