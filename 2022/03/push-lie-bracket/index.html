<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/><title>Lie括弧積の押し出し · Lumières Légeres</title><meta name="description" content="主に数学・物理についての個人的覚書集です。Next.jsでMathJaxを利用した数式を表示しています。"/><meta property="og:title" content="Lie括弧積の押し出し ･ Lumières Légeres"/><meta property="og:description" content="主に数学・物理についての個人的覚書集です。Next.jsでMathJaxを利用した数式を表示しています。"/><meta property="og:url" content="https://elle-et-noire.github.io/lumieres-legeres/2022/03/push-lie-bracket"/><meta property="og:image" content="https://user-images.githubusercontent.com/51241098/139921229-151ff350-13df-40c0-8709-b575bb6fdc6a.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@L48610"/><link rel="shortcut icon" href="https://user-images.githubusercontent.com/51241098/139574778-08c0d89e-b88e-4faa-baf5-4ee2af007b81.png" type="image/png"/><meta name="next-head-count" content="11"/><meta property="og:type" content="website"/><meta property="og:site_name" content="Lumières Légeres"/><link rel="preload" href="/lumieres-legeres/_next/static/css/8aa2d66df8169f5c.css" as="style"/><link rel="stylesheet" href="/lumieres-legeres/_next/static/css/8aa2d66df8169f5c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/lumieres-legeres/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/lumieres-legeres/_next/static/chunks/webpack-cdb411152df71aeb.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/main-a1be5da27e30f3a0.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/pages/_app-2a1881aa879d03eb.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/eb1842f2-946dec06d87bd412.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/304-636329ee9c75de46.js" defer=""></script><script src="/lumieres-legeres/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-226b56f13f58879f.js" defer=""></script><script src="/lumieres-legeres/_next/static/9Uyqg6c4Apfd6C5tp34aa/_buildManifest.js" defer=""></script><script src="/lumieres-legeres/_next/static/9Uyqg6c4Apfd6C5tp34aa/_ssgManifest.js" defer=""></script><script src="/lumieres-legeres/_next/static/9Uyqg6c4Apfd6C5tp34aa/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header><nav class="fixed w-full py-3 z-20 text-center font-semibold bg-transparent backdrop-filter backdrop-blur-sm bg-opacity-10" aria-label="Header navigation"><a class="px-5 py-3 no-underline font-mono tracking-tight" href="/lumieres-legeres/"><span class="text-xs text-gray-100 duration-1000">Lumières Légeres<!-- -->/<!-- --></span><span class="text-raspberry opacity-80 duration-1000"></span></a></nav></header><main class="flex-grow container mx-auto pt-28 pb-10"><div class="style_initial__lfW24" role="status"></div><div><article><header class="mb-8"><h1 class="mb-10"><span style="display:block;visibility:hidden">Lie括弧積の押し出し</span></h1><div class="italic text-right text-sm text-gray-400"><time dateTime="2022-03-28">Mar 28, 2022</time></div></header><span style="display:block;visibility:hidden"><div class="post"><p>成分表示に頼らずに書く。</p>
<!-- --><h2>接ベクトル</h2>
<!-- --><p><div class="scrollable">\begin{align}
  \qq*{曲線}c&amp;\colon (a,b)\to M\quad(a&lt;0&lt;b)\\
  \qq*{多様体上の関数}f&amp;\colon M\to\R
\end{align}</div>を用いて
<!-- --><div class="scrollable">\begin{align}
  X&amp;\in T_{c(0)}M\\
  \eval{\dv{f(c(t))}{t}}_{t=0}&amp;\eqqcolon X[f]\in \R
\end{align}</div>によって点<!-- --><span>\(\hspace{0.2em}c(0)\hspace{0.2em}\)</span>における接ベクトルを定義する。<!-- --><span>\(M\hspace{0.2em}\)</span>上のベクトル場は
<!-- --><div class="scrollable">\begin{align}
  \mathfrak{X}(M)\ni X&amp;\colon M\to TM\qc p\mapsto \eval{X}_p
\end{align}</div>と、多様体上の各点に接ベクトルを対応付ける関数と見なせる。<!-- --><span>\(f\hspace{0.2em}\)</span>を作用させたものは
<!-- --><div class="scrollable">\begin{align}
  X&amp;\in \mathfrak{X}(M)\\
  f&amp;\colon M\to\R\\
  X[f]&amp;\colon M\to\R\qc p\mapsto \eval{\dv{f(c(t))}{t}}_{c^{-1}(p)}
\end{align}</div>と見なせる。<!-- --></p>
<!-- --><h2>微分写像</h2>
<!-- --><p><span>\(\hspace{0.2em}f\colon M\to N\hspace{0.2em}\)</span>に対して微分写像
<!-- --><div class="scrollable">\begin{align}
  f_\ast&amp;\colon T_pM\to T_{f(p)}N
\end{align}</div>が誘導出来て
<!-- --><div class="scrollable">\begin{align}
  g&amp;\colon N\to \R\\
  \qq*{ベクトル}V&amp;\in T_pM\\
  \qq*{ベクトル}f_\ast V&amp;\in T_{f(p)}N\\
  (f_\ast V)[g]&amp;\coloneqq V[g\circ f]\in\R
\end{align}</div>と定義される。<!-- --></p>
<!-- --><p>ベクトル場の押し出しは
<!-- --><div class="scrollable">\begin{align}
  f&amp;\colon M\to N\\
  g&amp;\colon N\to \R\\
  X&amp;\in \mathfrak{X}(M)\\
  X[g\circ f]&amp;=f_\ast X[g]\circ f\colon M\to\R\\
  f_\ast X[g]&amp;\colon N\to \R
\end{align}</div>と見なせる。<!-- --></p>
<!-- --><h2>Lie括弧積</h2>
<!-- --><p><div class="scrollable">\begin{align}
  \qq*{ベクトル場}X,Y,\comm{X}{Y}&amp;\in\mathfrak{X}(M)\\
  f&amp;\colon M\to\R\\
  \comm{X}{Y}f&amp;\coloneqq X[Y[f]]-Y[X[f]]\colon M\to\R
\end{align}</div>
Lie括弧積が1階微分になることを成分に依らず示すことはできるのだろうか。<!-- --></p>
<!-- --><h2>Lie括弧積の押し出し</h2>
<!-- --><blockquote>
<!-- --><span>\(f_\ast\comm{X}{Y}=\comm{f_\ast X}{f_\ast Y}\hspace{0.2em}\)</span>
<!-- --></blockquote>
<!-- --><p><div class="scrollable">\begin{align}
  g&amp;\colon N\to\R\\
  (f_\ast\comm{X}{Y})[g]\circ f&amp;=\comm{X}{Y}(g\circ f)\\
  &amp;=X[Y[g\circ f]]-Y[X[g\circ f]]\\
  &amp;=X[f_\ast Y[g]\circ f]-Y[f_\ast X[g]\circ f]\\
  &amp;=f_\ast X[f_\ast Y[g]]\circ f-f_\ast Y[f_\ast X[g]]\circ f\\
  &amp;=(\comm{f_\ast X}{f_\ast Y}g)\circ f
\end{align}</div>ただし等号は関数としてのものである。<!-- --></p>
<!-- --><h2>引き戻し</h2>
<!-- --><p>ベクトルについては
<!-- --><div class="scrollable">\begin{align}
  V&amp;\in T_pM\qc \omega\in T^\ast_{f(p)}N\\
  f&amp;\colon M\to N\\
  \ev{f^\ast \omega, V}&amp;\coloneqq \ev{\omega, f_\ast V}\in\R
\end{align}</div>であり、ベクトル場については
<!-- --><div class="scrollable">\begin{align}
  V&amp;\in \mathfrak{X}(M)\qc \omega\in \Omega(N)\\
  f&amp;\colon M\to N\\
  \ev{f^\ast \omega, V}&amp;=\ev{\omega, f_\ast V}\circ f\colon M\to\R
\end{align}</div>と見なせる。<!-- --></p>
<!-- --><p><span>\(\hspace{0.2em}r\)</span>-形式については
<!-- --><div class="scrollable">\begin{align}
  f&amp;\colon M\to N\qc\omega\in\Omega^r(M)\\
  (f^\ast\omega)(X_1,\dots,X_r)&amp;\coloneqq \omega(f_\ast X_1,\dots,f_\ast X_r)\in\R\quad(X_i\in T_pM)\\
  (f^\ast\omega)(X_1,\dots,X_r)&amp;= \omega(f_\ast X_1,\dots,f_\ast X_r)\circ f\colon M\to\R\quad(X_i\in\mathfrak{X}(M))
\end{align}</div>と見なせる。<!-- --></p>
<!-- --><h2>外微分</h2>
<!-- --><p><div class="scrollable">\begin{align}
  \dd{\omega}(X,Y)&amp;=X[\omega(Y)]-Y[\omega(X)]-\omega(\comm{X}{Y})
\end{align}</div>と展開できることを用いて
<!-- --><div class="scrollable">\begin{align}
  \omega&amp;\in \Omega^2(N)\qc X,Y\in \mathfrak{X}(M)\qc f\colon M\to N\\
  \dd(f^\ast\omega)(X,Y)&amp;=X[f^\ast\omega(Y)]-Y[f^\ast\omega(X)]\circ f-f^\ast\omega(\comm{X}{Y})\\
  &amp;=X[\omega(f_\ast Y)\circ f]-Y[\omega(f_\ast X)\circ f]-\omega(f_\ast\comm{X}{Y}\circ f)\\
  &amp;=f_\ast X[\omega(f_\ast Y)]\circ f-f_\ast Y[\omega(f_\ast X)]\circ f-\omega(\comm{f_\ast X}{f_\ast Y}\circ f)\\
  &amp;=\dd{\omega}(f_\ast X,f_\ast Y)\circ f\\
  &amp;=f^\ast(\dd{\omega})(X,Y)
\end{align}</div>と、外微分と引き戻しが可換であることが分かる。<!-- --></p></div></span><p class="mt-16 text-center"><a class="px-5 font-semibold" href="/lumieres-legeres/">Home</a></p></article></div></main><div class="mb-3 font-semibold text-center text-xs text-gray-500">© 2022 @L48610</div><footer class="py-3 text-center font-semibold bg-emerald"><nav class="text-sm" aria-label="Footer navigation"><a class="px-5 py-3" href="/lumieres-legeres/about/">About</a><a class="px-5 py-3" href="/lumieres-legeres/contact/">Contact</a></nav></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Lie括弧積の押し出し","date":"2022-03-28","tags":"math","year":"2022","month":"03","slug":"push-lie-bracket","description":"主に数学・物理についての個人的覚書集です。Next.jsでMathJaxを利用した数式を表示しています。","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h2: \"h2\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"成分表示に頼らずに書く。\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"接ベクトル\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\qq*{曲線}c\u0026\\\\colon (a,b)\\\\to M\\\\quad(a\u003c0\u003cb)\\\\\\\\\n  \\\\qq*{多様体上の関数}f\u0026\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"を用いて\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  X\u0026\\\\in T_{c(0)}M\\\\\\\\\n  \\\\eval{\\\\dv{f(c(t))}{t}}_{t=0}\u0026\\\\eqqcolon X[f]\\\\in \\\\R\n\\\\end{align}`\n        }), \"によって点\", _jsx(\"span\", {\n          children: `\\\\(\\\\hspace{0.2em}c(0)\\\\hspace{0.2em}\\\\)`\n        }), \"における接ベクトルを定義する。\", _jsx(\"span\", {\n          children: `\\\\(M\\\\hspace{0.2em}\\\\)`\n        }), \"上のベクトル場は\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\mathfrak{X}(M)\\\\ni X\u0026\\\\colon M\\\\to TM\\\\qc p\\\\mapsto \\\\eval{X}_p\n\\\\end{align}`\n        }), \"と、多様体上の各点に接ベクトルを対応付ける関数と見なせる。\", _jsx(\"span\", {\n          children: `\\\\(f\\\\hspace{0.2em}\\\\)`\n        }), \"を作用させたものは\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  X\u0026\\\\in \\\\mathfrak{X}(M)\\\\\\\\\n  f\u0026\\\\colon M\\\\to\\\\R\\\\\\\\\n  X[f]\u0026\\\\colon M\\\\to\\\\R\\\\qc p\\\\mapsto \\\\eval{\\\\dv{f(c(t))}{t}}_{c^{-1}(p)}\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"微分写像\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          children: `\\\\(\\\\hspace{0.2em}f\\\\colon M\\\\to N\\\\hspace{0.2em}\\\\)`\n        }), \"に対して微分写像\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f_\\\\ast\u0026\\\\colon T_pM\\\\to T_{f(p)}N\n\\\\end{align}`\n        }), \"が誘導出来て\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  g\u0026\\\\colon N\\\\to \\\\R\\\\\\\\\n  \\\\qq*{ベクトル}V\u0026\\\\in T_pM\\\\\\\\\n  \\\\qq*{ベクトル}f_\\\\ast V\u0026\\\\in T_{f(p)}N\\\\\\\\\n  (f_\\\\ast V)[g]\u0026\\\\coloneqq V[g\\\\circ f]\\\\in\\\\R\n\\\\end{align}`\n        }), \"と定義される。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"ベクトル場の押し出しは\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f\u0026\\\\colon M\\\\to N\\\\\\\\\n  g\u0026\\\\colon N\\\\to \\\\R\\\\\\\\\n  X\u0026\\\\in \\\\mathfrak{X}(M)\\\\\\\\\n  X[g\\\\circ f]\u0026=f_\\\\ast X[g]\\\\circ f\\\\colon M\\\\to\\\\R\\\\\\\\\n  f_\\\\ast X[g]\u0026\\\\colon N\\\\to \\\\R\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Lie括弧積\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\qq*{ベクトル場}X,Y,\\\\comm{X}{Y}\u0026\\\\in\\\\mathfrak{X}(M)\\\\\\\\\n  f\u0026\\\\colon M\\\\to\\\\R\\\\\\\\\n  \\\\comm{X}{Y}f\u0026\\\\coloneqq X[Y[f]]-Y[X[f]]\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"\\r\\nLie括弧積が1階微分になることを成分に依らず示すことはできるのだろうか。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Lie括弧積の押し出し\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(\"span\", {\n          children: `\\\\(f_\\\\ast\\\\comm{X}{Y}=\\\\comm{f_\\\\ast X}{f_\\\\ast Y}\\\\hspace{0.2em}\\\\)`\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  g\u0026\\\\colon N\\\\to\\\\R\\\\\\\\\n  (f_\\\\ast\\\\comm{X}{Y})[g]\\\\circ f\u0026=\\\\comm{X}{Y}(g\\\\circ f)\\\\\\\\\n  \u0026=X[Y[g\\\\circ f]]-Y[X[g\\\\circ f]]\\\\\\\\\n  \u0026=X[f_\\\\ast Y[g]\\\\circ f]-Y[f_\\\\ast X[g]\\\\circ f]\\\\\\\\\n  \u0026=f_\\\\ast X[f_\\\\ast Y[g]]\\\\circ f-f_\\\\ast Y[f_\\\\ast X[g]]\\\\circ f\\\\\\\\\n  \u0026=(\\\\comm{f_\\\\ast X}{f_\\\\ast Y}g)\\\\circ f\n\\\\end{align}`\n        }), \"ただし等号は関数としてのものである。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"引き戻し\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"ベクトルについては\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  V\u0026\\\\in T_pM\\\\qc \\\\omega\\\\in T^\\\\ast_{f(p)}N\\\\\\\\\n  f\u0026\\\\colon M\\\\to N\\\\\\\\\n  \\\\ev{f^\\\\ast \\\\omega, V}\u0026\\\\coloneqq \\\\ev{\\\\omega, f_\\\\ast V}\\\\in\\\\R\n\\\\end{align}`\n        }), \"であり、ベクトル場については\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  V\u0026\\\\in \\\\mathfrak{X}(M)\\\\qc \\\\omega\\\\in \\\\Omega(N)\\\\\\\\\n  f\u0026\\\\colon M\\\\to N\\\\\\\\\n  \\\\ev{f^\\\\ast \\\\omega, V}\u0026=\\\\ev{\\\\omega, f_\\\\ast V}\\\\circ f\\\\colon M\\\\to\\\\R\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          children: `\\\\(\\\\hspace{0.2em}r\\\\)`\n        }), \"-形式については\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  f\u0026\\\\colon M\\\\to N\\\\qc\\\\omega\\\\in\\\\Omega^r(M)\\\\\\\\\n  (f^\\\\ast\\\\omega)(X_1,\\\\dots,X_r)\u0026\\\\coloneqq \\\\omega(f_\\\\ast X_1,\\\\dots,f_\\\\ast X_r)\\\\in\\\\R\\\\quad(X_i\\\\in T_pM)\\\\\\\\\n  (f^\\\\ast\\\\omega)(X_1,\\\\dots,X_r)\u0026= \\\\omega(f_\\\\ast X_1,\\\\dots,f_\\\\ast X_r)\\\\circ f\\\\colon M\\\\to\\\\R\\\\quad(X_i\\\\in\\\\mathfrak{X}(M))\n\\\\end{align}`\n        }), \"と見なせる。\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"外微分\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\dd{\\\\omega}(X,Y)\u0026=X[\\\\omega(Y)]-Y[\\\\omega(X)]-\\\\omega(\\\\comm{X}{Y})\n\\\\end{align}`\n        }), \"と展開できることを用いて\\r\\n\", _jsx(\"div\", {\n          className: \"scrollable\",\n          children: `\\\\begin{align}\n  \\\\omega\u0026\\\\in \\\\Omega^2(N)\\\\qc X,Y\\\\in \\\\mathfrak{X}(M)\\\\qc f\\\\colon M\\\\to N\\\\\\\\\n  \\\\dd(f^\\\\ast\\\\omega)(X,Y)\u0026=X[f^\\\\ast\\\\omega(Y)]-Y[f^\\\\ast\\\\omega(X)]\\\\circ f-f^\\\\ast\\\\omega(\\\\comm{X}{Y})\\\\\\\\\n  \u0026=X[\\\\omega(f_\\\\ast Y)\\\\circ f]-Y[\\\\omega(f_\\\\ast X)\\\\circ f]-\\\\omega(f_\\\\ast\\\\comm{X}{Y}\\\\circ f)\\\\\\\\\n  \u0026=f_\\\\ast X[\\\\omega(f_\\\\ast Y)]\\\\circ f-f_\\\\ast Y[\\\\omega(f_\\\\ast X)]\\\\circ f-\\\\omega(\\\\comm{f_\\\\ast X}{f_\\\\ast Y}\\\\circ f)\\\\\\\\\n  \u0026=\\\\dd{\\\\omega}(f_\\\\ast X,f_\\\\ast Y)\\\\circ f\\\\\\\\\n  \u0026=f^\\\\ast(\\\\dd{\\\\omega})(X,Y)\n\\\\end{align}`\n        }), \"と、外微分と引き戻しが可換であることが分かる。\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"mathblocks":[]},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2022","month":"03","slug":"push-lie-bracket"},"buildId":"9Uyqg6c4Apfd6C5tp34aa","assetPrefix":"/lumieres-legeres","runtimeConfig":{"basePath":"/lumieres-legeres"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>