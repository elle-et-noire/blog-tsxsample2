<!DOCTYPE html><html lang="ja"><head><meta property="og:type" content="website"/><meta property="og:site_name" content="elle-et-noire/blog-tsxsample2"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/><title>可換な演算子の同時対角化可能性 · elle-et-noire/blog-tsxsample2</title><meta name="description" content="対角化可能な演算子 \(A,B\) が可換なら \(A,B\) は同時対角化可能である。"/><meta property="og:title" content="可換な演算子の同時対角化可能性 ･ elle-et-noire/blog-tsxsample2"/><meta property="og:description" content="対角化可能な演算子 \(A,B\) が可換なら \(A,B\) は同時対角化可能である。"/><meta property="og:url" content="https://elle-et-noire.github.io/blog-tsxsample2/2022/01/diag-braket"/><meta name="next-head-count" content="7"/><link rel="preload" href="/blog-tsxsample2/_next/static/css/9d6f5876c914c2c0.css" as="style"/><link rel="stylesheet" href="/blog-tsxsample2/_next/static/css/9d6f5876c914c2c0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog-tsxsample2/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/blog-tsxsample2/_next/static/chunks/webpack-9b6fc359924a2402.js" defer=""></script><script src="/blog-tsxsample2/_next/static/chunks/framework-6e4ba497ae0c8a3f.js" defer=""></script><script src="/blog-tsxsample2/_next/static/chunks/main-b3b3e04c8cdcd10e.js" defer=""></script><script src="/blog-tsxsample2/_next/static/chunks/pages/_app-215d18d9b9f27cd3.js" defer=""></script><script src="/blog-tsxsample2/_next/static/chunks/919-231013f5e47261ba.js" defer=""></script><script src="/blog-tsxsample2/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-a60d32a7e56a9f9c.js" defer=""></script><script src="/blog-tsxsample2/_next/static/nlqcoDwU8twm8eFdgXKta/_buildManifest.js" defer=""></script><script src="/blog-tsxsample2/_next/static/nlqcoDwU8twm8eFdgXKta/_ssgManifest.js" defer=""></script><script src="/blog-tsxsample2/_next/static/nlqcoDwU8twm8eFdgXKta/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="flex flex-col min-h-screen"><header><nav class="fixed w-full py-3 z-20 text-center font-semibold bg-transparent backdrop-filter backdrop-blur-sm bg-opacity-10" aria-label="Header navigation"><a class="px-5 py-3 no-underline font-mono tracking-tight" href="/blog-tsxsample2/"><span class="text-xs text-gray-100 duration-1000">elle-et-noire<!-- -->/</span><span class="text-raspberry opacity-80 duration-1000">blog-tsxsample2</span></a></nav></header><main class="flex-grow container mx-auto pt-28 pb-10"><div class="style_initial__lfW24" role="status"></div><div><article><header class="mb-8"><h1 class="mb-10">可換な演算子の同時対角化可能性</h1><div class="italic text-right text-sm text-gray-400"><time dateTime="2022-01-30">Jan 30, 2022</time></div></header><div class="post">
<h2>命題</h2>
<blockquote>
  <p>対角化可能な演算子 \(A,B\) が可換なら \(A,B\) は同時対角化可能である。</p>
</blockquote>
<h2>証明</h2>
<p>$\hspace{0.2em}A\hspace{0.2em}$の相異なる固有値を$\hspace{0.2em}\qty{a\underscore{i}}\underscore{i}\hspace{0.2em}$とし、$\hspace{0.2em}a\underscore{i}\hspace{0.2em}$に対応する固有空間への射影演算子を$\hspace{0.2em}\mathcal{P}\underscore{i}\hspace{0.2em}$とする。同様に$\hspace{0.2em}B\hspace{0.2em}$の相異なる固有値$\hspace{0.2em}\qty{b\underscore{j}}\underscore{j}\hspace{0.2em}$および対応する射影演算子$\hspace{0.2em}\qty{\mathcal{Q}\underscore{j}}\underscore{j}\hspace{0.2em}$も定める。すると</p><p>\begin{align}
A&=\sum_i a_i\mathcal{P}_i,& \sum_i\mathcal{P}_i&=I,&\mathcal{P}_i\mathcal{P}_{i'}&=\delta_{ii'}\mathcal{P}_i\label{eq:a}\\
B&=\sum_j b_j\mathcal{Q}_j,& \sum_j\mathcal{Q}_j&=I,&\mathcal{Q}_j\mathcal{Q}_{j'}&=\delta_{jj'}\mathcal{Q}_j\label{eq:b}
\end{align}</p>
<p>より</p><p>\begin{align}
\mathcal{P}_i&=\dfrac{\prod_{l\neq i}(A-a_lI)}{\prod_{l\neq i}(a_i-a_l)}\\
\mathcal{Q}_j&=\dfrac{\prod_{m\neq j}(B-b_mI)}{\prod_{m\neq j}(b_j-b_m)}
\end{align}</p>
<p>と表せる。実際$\hspace{0.2em}l\neq i\hspace{0.2em}$に対して</p><p>\begin{align*}
\dfrac{A-a_lI}{a_i-a_l}&=\mathcal{P}_i+\sum_{n\neq l,i}\dfrac{a_n-a_l}{a_i-a_l}\mathcal{P}_n
\end{align*}</p>
<p>となり、これを$\hspace{0.2em}l\neq i\hspace{0.2em}$に亘って掛け合わせると$\hspace{0.2em}\mathcal{P}\underscore{i}\hspace{0.2em}$だけが残る。$\hspace{0.2em}\mathcal{Q}\underscore{i}\hspace{0.2em}$も同様。そして、$\hspace{0.2em}\mathcal{P}\underscore{i},\mathcal{Q}\underscore{j}\hspace{0.2em}$は$\hspace{0.2em}A,B,I\hspace{0.2em}$だけで表されているので可換である：</p><p>\begin{align}
\comm{\mathcal{P}_i}{\mathcal{Q}_j}=0.
\end{align}</p>
<p>このとき</p><p>\begin{align}
\sum_{i,j}\mathcal{P}_i\mathcal{Q}_j=&I,&(\mathcal{P}_i\mathcal{Q}_j)(\mathcal{P}_{i'}\mathcal{Q}_{j'})&=\delta_{ii'}\delta_{jj'}\mathcal{P}_i\mathcal{Q}_j\label{eq:pq-split}
\end{align}</p>
<p>が成り立つので$\hspace{0.2em}\qty{\mathcal{P}\underscore{i}\mathcal{Q}\underscore{j}}\underscore{i,j}\hspace{0.2em}$は射影であり、\eqref{eq:a}、\eqref{eq:b}から導かれる</p><p>\begin{align}
A&=\sum_{i,j} a_i\mathcal{P}_i\mathcal{Q}_j\\
B&=\sum_{i,j} b_j\mathcal{P}_i\mathcal{Q}_j
\end{align}</p>
<p>はスペクトル分解になっている。$\hspace{0.2em}\mathcal{P}\underscore{i}\hspace{0.2em}$に対応する固有空間を$\hspace{0.2em}W\underscore{i}\hspace{0.2em}$、$\hspace{0.2em}\mathcal{Q}\underscore{j}\hspace{0.2em}$に対応する固有空間を$\hspace{0.2em}V\underscore{j}\hspace{0.2em}$とすると、$\hspace{0.2em}\eqref{eq:pq-split}\hspace{0.2em}$は$\hspace{0.2em}\qty{W\underscore{i}\cap V\underscore{j}}\underscore{i,j}\hspace{0.2em}$によって Hilbert 空間$\hspace{0.2em}\mathcal{H}\hspace{0.2em}$を直和分解できることを意味している。各$\hspace{0.2em}W\underscore{i}\cap V\underscore{j}\hspace{0.2em}$は依然$\hspace{0.2em}2\hspace{0.2em}$次以上の次元を持ちうるので適宜（Schmidt の直交化法などにより）$\hspace{0.2em}W\underscore{i}\cap V\underscore{j}\hspace{0.2em}$内の正規直交基底をとることで、$\hspace{0.2em}\mathcal{H}\hspace{0.2em}$全体の正規直交基底$\hspace{0.2em}\qty{\ket{a\underscore{i},b\underscore{j},k}}\underscore{i,j,k}\hspace{0.2em}$であって</p><p>\begin{align}
A\ket{a_i,b_j,k}&=a_i\ket{a_i,b_j,k},& B\ket{a_i,b_j,k}=b_j\ket{a_i,b_j,k}
\end{align}</p>
<p>を満たすようなものを取ることができる。すなわち$\hspace{0.2em}A,B\hspace{0.2em}$は同時対角化可能である。</p>
<h2>余談</h2>
<p>$\hspace{0.2em}\comm{A}{B}=0,\comm{B}{C}=0\implies\comm{A}{C}=0\hspace{0.2em}$だと何故か思い込んでいたけれど$\hspace{0.2em}B=\mathbb{1}\hspace{0.2em}$が反例でした。</p>
<h1>参考文献</h1>
<p><a href="https://www.ims.tsukuba.ac.jp/~shugo_suzuki_lab/upload.pdf" target="_blank" rel="nofollow noopener noreferrer">ディラック記法による線形代数（PDF）</a></p><script>
MathJax = {
        loader: {load: ['[tex]/physics', '[tex]/mathtools', '[tex]/color', '[tex]/upgreek', '[tex]/centernot', '[tex]/tagformat']},
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          packages: { '[+]': ['physics', 'mathtools', 'color', 'upgreek', 'centernot', 'tagformat'] },
          color: {
            padding: '5px',
            borderWidth: '2px',
          },
          macros: {
            parn: ["\\biggl(#1\\biggr)", 1],
            sqbr: ["\\biggl[#1\\biggr]", 1],
            pfrac: ["\\biggl(\\dfrac{#1}{#2}\\biggr)", 2],
            ds: "\\displaystyle",
            C: '{\\mathbb C}',
            R: '{\\mathbb R}',
            Q: '{\\mathbb Q}',
            Z: '{\\mathbb Z}',
            ssqrt: ['\\sqrt{\\smash[b]{\\mathstrut #1}}', 1],
            tcdegree: ['\\unicode{xb0}'],
            tccelsius: ['\\unicode{x2103}'],
            tcperthousand: ['\\unicode{x2030}'],
            tcmu: ['\\unicode{x3bc}'],
            tcohm: ['\\unicode{x3a9}'],
            bm: ['\\boldsymbol{#1}', 1],
            ol: ['\\overline{#1}', 1],
            ul: ['\\underline{#1}', 1],
            ub: ['\\underbrace{#1}', 1],
            ubt: ['\\underbrace{#1}_{\\text{#2}}', 2],
            i: '{\\mathrm{i}}',
            e: '{\\mathrm{e}}',
            ve: '{\\varepsilon}',
            slashed: ['{{#1\\!\\!\\!/}}', 1],
            underscore: '_',
          },
          physics: {
            italicdiff: true,
            arrowdel: false,
          },
          section: 1,
          tagformat: {
            // number: (n) => MathJax.config.section + '.' + n,
            number: (n) => n.toString(),
            // tag:    (tag) => '(' + tag + ')',
            id:     (tag) => 'eqn-id:' + tag,
            url:    (id, base) => base + '#' + encodeURIComponent(id),
          },
          tags: 'ams',
          tagSide: 'right',
          tagIndent: '0.8em',
          processRefs: true,
          useLabelIds: false,         // use label name rather than tag for ids
        },
        svg: {
          fontCache: 'global'
        },
        chtml: {
          displayAlign: 'left',
          displayIndent: '2em',
          mtextInheritFont: true,
        },
        startup: {
          ready() {
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            new CommandMap('sections', {
              nextSection: 'NextSection',
              setSection: 'SetSection',
            }, {
              NextSection(parser, name) {
                MathJax.config.section++;
                parser.tags.counter = parser.tags.allCounter = 0;
              },
              SetSection(parser, name) {
                const n = parser.GetArgument(name);
                MathJax.config.section = parseInt(n);
              }
            });
            Configuration.create(
              'sections', {handler: {macro: ['sections']}}
            );
            MathJax.startup.defaultReady();
            MathJax.startup.input[0].preFilters.add(({math}) => {
              if (math.inputData.recompile) {
                MathJax.config.section = math.inputData.recompile.section;
              }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
              if (math.inputData.recompile) {
                math.inputData.recompile.section = MathJax.config.section;
              }
            });
          }
        }
      };
</script>
<script id="MathJax-script"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.min.js?config=TeX-AMS_HTML">
</script>
</div><p class="mt-16 text-center"><a class="px-5 py-3 font-semibold" href="/blog-tsxsample2/">Home</a></p></article></div></main><div class="mb-3 font-semibold text-center text-xs text-gray-500">© 2022 @L48610</div><footer class="py-3 text-center font-semibold bg-darkgreen"><nav class="text-sm" aria-label="Footer navigation"><a class="px-5 py-3" href="/blog-tsxsample2/about/">About</a><a class="px-5 py-3" href="/blog-tsxsample2/contact/">Contact</a></nav></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"可換な演算子の同時対角化可能性","date":"2022-01-30","tags":["math"],"year":"2022","month":"01","slug":"diag-braket","content":"\n\u003ch2\u003e命題\u003c/h2\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e対角化可能な演算子 \\(A,B\\) が可換なら \\(A,B\\) は同時対角化可能である。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e証明\u003c/h2\u003e\n\u003cp\u003e$\\hspace{0.2em}A\\hspace{0.2em}$の相異なる固有値を$\\hspace{0.2em}\\qty{a\\underscore{i}}\\underscore{i}\\hspace{0.2em}$とし、$\\hspace{0.2em}a\\underscore{i}\\hspace{0.2em}$に対応する固有空間への射影演算子を$\\hspace{0.2em}\\mathcal{P}\\underscore{i}\\hspace{0.2em}$とする。同様に$\\hspace{0.2em}B\\hspace{0.2em}$の相異なる固有値$\\hspace{0.2em}\\qty{b\\underscore{j}}\\underscore{j}\\hspace{0.2em}$および対応する射影演算子$\\hspace{0.2em}\\qty{\\mathcal{Q}\\underscore{j}}\\underscore{j}\\hspace{0.2em}$も定める。すると\u003c/p\u003e\u003cp\u003e\\begin{align}\nA\u0026=\\sum_i a_i\\mathcal{P}_i,\u0026 \\sum_i\\mathcal{P}_i\u0026=I,\u0026\\mathcal{P}_i\\mathcal{P}_{i'}\u0026=\\delta_{ii'}\\mathcal{P}_i\\label{eq:a}\\\\\nB\u0026=\\sum_j b_j\\mathcal{Q}_j,\u0026 \\sum_j\\mathcal{Q}_j\u0026=I,\u0026\\mathcal{Q}_j\\mathcal{Q}_{j'}\u0026=\\delta_{jj'}\\mathcal{Q}_j\\label{eq:b}\n\\end{align}\u003c/p\u003e\n\u003cp\u003eより\u003c/p\u003e\u003cp\u003e\\begin{align}\n\\mathcal{P}_i\u0026=\\dfrac{\\prod_{l\\neq i}(A-a_lI)}{\\prod_{l\\neq i}(a_i-a_l)}\\\\\n\\mathcal{Q}_j\u0026=\\dfrac{\\prod_{m\\neq j}(B-b_mI)}{\\prod_{m\\neq j}(b_j-b_m)}\n\\end{align}\u003c/p\u003e\n\u003cp\u003eと表せる。実際$\\hspace{0.2em}l\\neq i\\hspace{0.2em}$に対して\u003c/p\u003e\u003cp\u003e\\begin{align*}\n\\dfrac{A-a_lI}{a_i-a_l}\u0026=\\mathcal{P}_i+\\sum_{n\\neq l,i}\\dfrac{a_n-a_l}{a_i-a_l}\\mathcal{P}_n\n\\end{align*}\u003c/p\u003e\n\u003cp\u003eとなり、これを$\\hspace{0.2em}l\\neq i\\hspace{0.2em}$に亘って掛け合わせると$\\hspace{0.2em}\\mathcal{P}\\underscore{i}\\hspace{0.2em}$だけが残る。$\\hspace{0.2em}\\mathcal{Q}\\underscore{i}\\hspace{0.2em}$も同様。そして、$\\hspace{0.2em}\\mathcal{P}\\underscore{i},\\mathcal{Q}\\underscore{j}\\hspace{0.2em}$は$\\hspace{0.2em}A,B,I\\hspace{0.2em}$だけで表されているので可換である：\u003c/p\u003e\u003cp\u003e\\begin{align}\n\\comm{\\mathcal{P}_i}{\\mathcal{Q}_j}=0.\n\\end{align}\u003c/p\u003e\n\u003cp\u003eこのとき\u003c/p\u003e\u003cp\u003e\\begin{align}\n\\sum_{i,j}\\mathcal{P}_i\\mathcal{Q}_j=\u0026I,\u0026(\\mathcal{P}_i\\mathcal{Q}_j)(\\mathcal{P}_{i'}\\mathcal{Q}_{j'})\u0026=\\delta_{ii'}\\delta_{jj'}\\mathcal{P}_i\\mathcal{Q}_j\\label{eq:pq-split}\n\\end{align}\u003c/p\u003e\n\u003cp\u003eが成り立つので$\\hspace{0.2em}\\qty{\\mathcal{P}\\underscore{i}\\mathcal{Q}\\underscore{j}}\\underscore{i,j}\\hspace{0.2em}$は射影であり、\\eqref{eq:a}、\\eqref{eq:b}から導かれる\u003c/p\u003e\u003cp\u003e\\begin{align}\nA\u0026=\\sum_{i,j} a_i\\mathcal{P}_i\\mathcal{Q}_j\\\\\nB\u0026=\\sum_{i,j} b_j\\mathcal{P}_i\\mathcal{Q}_j\n\\end{align}\u003c/p\u003e\n\u003cp\u003eはスペクトル分解になっている。$\\hspace{0.2em}\\mathcal{P}\\underscore{i}\\hspace{0.2em}$に対応する固有空間を$\\hspace{0.2em}W\\underscore{i}\\hspace{0.2em}$、$\\hspace{0.2em}\\mathcal{Q}\\underscore{j}\\hspace{0.2em}$に対応する固有空間を$\\hspace{0.2em}V\\underscore{j}\\hspace{0.2em}$とすると、$\\hspace{0.2em}\\eqref{eq:pq-split}\\hspace{0.2em}$は$\\hspace{0.2em}\\qty{W\\underscore{i}\\cap V\\underscore{j}}\\underscore{i,j}\\hspace{0.2em}$によって Hilbert 空間$\\hspace{0.2em}\\mathcal{H}\\hspace{0.2em}$を直和分解できることを意味している。各$\\hspace{0.2em}W\\underscore{i}\\cap V\\underscore{j}\\hspace{0.2em}$は依然$\\hspace{0.2em}2\\hspace{0.2em}$次以上の次元を持ちうるので適宜（Schmidt の直交化法などにより）$\\hspace{0.2em}W\\underscore{i}\\cap V\\underscore{j}\\hspace{0.2em}$内の正規直交基底をとることで、$\\hspace{0.2em}\\mathcal{H}\\hspace{0.2em}$全体の正規直交基底$\\hspace{0.2em}\\qty{\\ket{a\\underscore{i},b\\underscore{j},k}}\\underscore{i,j,k}\\hspace{0.2em}$であって\u003c/p\u003e\u003cp\u003e\\begin{align}\nA\\ket{a_i,b_j,k}\u0026=a_i\\ket{a_i,b_j,k},\u0026 B\\ket{a_i,b_j,k}=b_j\\ket{a_i,b_j,k}\n\\end{align}\u003c/p\u003e\n\u003cp\u003eを満たすようなものを取ることができる。すなわち$\\hspace{0.2em}A,B\\hspace{0.2em}$は同時対角化可能である。\u003c/p\u003e\n\u003ch2\u003e余談\u003c/h2\u003e\n\u003cp\u003e$\\hspace{0.2em}\\comm{A}{B}=0,\\comm{B}{C}=0\\implies\\comm{A}{C}=0\\hspace{0.2em}$だと何故か思い込んでいたけれど$\\hspace{0.2em}B=\\mathbb{1}\\hspace{0.2em}$が反例でした。\u003c/p\u003e\n\u003ch1\u003e参考文献\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://www.ims.tsukuba.ac.jp/~shugo_suzuki_lab/upload.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eディラック記法による線形代数（PDF）\u003c/a\u003e\u003c/p\u003e\u003cscript\u003e\nMathJax = {\n        loader: {load: ['[tex]/physics', '[tex]/mathtools', '[tex]/color', '[tex]/upgreek', '[tex]/centernot', '[tex]/tagformat']},\n        tex: {\n          inlineMath: [['$', '$'], ['\\\\(', '\\\\)']],\n          packages: { '[+]': ['physics', 'mathtools', 'color', 'upgreek', 'centernot', 'tagformat'] },\n          color: {\n            padding: '5px',\n            borderWidth: '2px',\n          },\n          macros: {\n            parn: [\"\\\\biggl(#1\\\\biggr)\", 1],\n            sqbr: [\"\\\\biggl[#1\\\\biggr]\", 1],\n            pfrac: [\"\\\\biggl(\\\\dfrac{#1}{#2}\\\\biggr)\", 2],\n            ds: \"\\\\displaystyle\",\n            C: '{\\\\mathbb C}',\n            R: '{\\\\mathbb R}',\n            Q: '{\\\\mathbb Q}',\n            Z: '{\\\\mathbb Z}',\n            ssqrt: ['\\\\sqrt{\\\\smash[b]{\\\\mathstrut #1}}', 1],\n            tcdegree: ['\\\\unicode{xb0}'],\n            tccelsius: ['\\\\unicode{x2103}'],\n            tcperthousand: ['\\\\unicode{x2030}'],\n            tcmu: ['\\\\unicode{x3bc}'],\n            tcohm: ['\\\\unicode{x3a9}'],\n            bm: ['\\\\boldsymbol{#1}', 1],\n            ol: ['\\\\overline{#1}', 1],\n            ul: ['\\\\underline{#1}', 1],\n            ub: ['\\\\underbrace{#1}', 1],\n            ubt: ['\\\\underbrace{#1}_{\\\\text{#2}}', 2],\n            i: '{\\\\mathrm{i}}',\n            e: '{\\\\mathrm{e}}',\n            ve: '{\\\\varepsilon}',\n            slashed: ['{{#1\\\\!\\\\!\\\\!/}}', 1],\n            underscore: '_',\n          },\n          physics: {\n            italicdiff: true,\n            arrowdel: false,\n          },\n          section: 1,\n          tagformat: {\n            // number: (n) =\u003e MathJax.config.section + '.' + n,\n            number: (n) =\u003e n.toString(),\n            // tag:    (tag) =\u003e '(' + tag + ')',\n            id:     (tag) =\u003e 'eqn-id:' + tag,\n            url:    (id, base) =\u003e base + '#' + encodeURIComponent(id),\n          },\n          tags: 'ams',\n          tagSide: 'right',\n          tagIndent: '0.8em',\n          processRefs: true,\n          useLabelIds: false,         // use label name rather than tag for ids\n        },\n        svg: {\n          fontCache: 'global'\n        },\n        chtml: {\n          displayAlign: 'left',\n          displayIndent: '2em',\n          mtextInheritFont: true,\n        },\n        startup: {\n          ready() {\n            const Configuration = MathJax._.input.tex.Configuration.Configuration;\n            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;\n            new CommandMap('sections', {\n              nextSection: 'NextSection',\n              setSection: 'SetSection',\n            }, {\n              NextSection(parser, name) {\n                MathJax.config.section++;\n                parser.tags.counter = parser.tags.allCounter = 0;\n              },\n              SetSection(parser, name) {\n                const n = parser.GetArgument(name);\n                MathJax.config.section = parseInt(n);\n              }\n            });\n            Configuration.create(\n              'sections', {handler: {macro: ['sections']}}\n            );\n            MathJax.startup.defaultReady();\n            MathJax.startup.input[0].preFilters.add(({math}) =\u003e {\n              if (math.inputData.recompile) {\n                MathJax.config.section = math.inputData.recompile.section;\n              }\n            });\n            MathJax.startup.input[0].postFilters.add(({math}) =\u003e {\n              if (math.inputData.recompile) {\n                math.inputData.recompile.section = MathJax.config.section;\n              }\n            });\n          }\n        }\n      };\n\u003c/script\u003e\n\u003cscript id=\"MathJax-script\"\n  src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.min.js?config=TeX-AMS_HTML\"\u003e\n\u003c/script\u003e\n"}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2022","month":"01","slug":"diag-braket"},"buildId":"nlqcoDwU8twm8eFdgXKta","assetPrefix":"/blog-tsxsample2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>